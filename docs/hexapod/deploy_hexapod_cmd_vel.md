---
sidebar_position: 11
title: hexapod 步态调试记录
---
六足机器人通过发送cmd_vel控制机器人运动，目前发现：发送的cmd_vel符合一般的通信协议，但实际的运动姿态却是相反的，怀疑是源码中，对代码进行了混淆
所以需要进行二次的修改，修改的方式如下：

## 修改步态映射
### 修改control.cpp
- 读取配置文件里面的参数
    ```cpp
    // 获取最大的转弯范围
        ros::param::get("MAX_RADIANS_PER_SEC", maxRadiansPerSec);
        // 获取最大的行进速度范围
        ros::param::get("MAX_METERS_PER_SEC", maxMeterPerSec);
    ```
- 添加映射函数
    ```cpp
    /**
    * 数据范围映射函数
    * @param data 源数据
    * @param inMin 最小的输入值
    * @param inMax 最大的输入值
    * @param outMin 最小的输出值
    * @param outMax 最大的输出值
    * @return 处理过后的数据
    */
    double Control::mapData(double data, double inMin, double inMax, double outMin, double outMax)
    {
        return ((data - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    ```

- 在订阅`cmd_vel`的地方进行数据的替换
    ```cpp
    void Control::cmd_velCallback(const geometry_msgs::TwistConstPtr &cmd_vel_msg)
    {
        // cmd_vel_msg->linear.x现在这个对应的是转弯的数据，要把它映射成前进的数据，即是设定angular.z的值，目前范围是-0.3~0.3
        double angularZ = 0;
        if (cmd_vel_msg->linear.x < 0)
        {
            angularZ = mapData(cmd_vel_msg->linear.x, -maxMeterPerSec, 0, -maxRadiansPerSec, 0);
        }
        else if (cmd_vel_msg->linear.x > 0)
        {
            angularZ = mapData(cmd_vel_msg->linear.x, 0, maxMeterPerSec, 0, maxRadiansPerSec);
        }

        double linearX = 0;
        if (cmd_vel_msg->angular.z < 0)
        {
            linearX = mapData(cmd_vel_msg->angular.z, -maxRadiansPerSec, 0, -maxMeterPerSec, 0);
        }
        else if (cmd_vel_msg->angular.z > 0)
        {
            linearX = mapData(cmd_vel_msg->angular.z, 0, maxRadiansPerSec, 0, maxMeterPerSec);
        }
        // ROS_INFO("angularZ: [%f], linearX: [%f]", angularZ, linearX);
        cmd_vel_incoming_.linear.x = linearX;
        cmd_vel_incoming_.linear.y = cmd_vel_msg->linear.y;
        // cmd_vel_incoming_.angular.z = cmd_vel_msg->angular.z;
        cmd_vel_incoming_.angular.z = angularZ;
    }
    ```

## 舵机偏差调节
在hexapod中我们要调整舵机的偏差，可以修改`hexapod_controller`中的`servo_driver.cpp`文件，动态调节相关的offset值
### 定义hexapod_msgs消息
我们首先定义我们的舵机偏差消息：
- OffsetServo: 订阅的舵机偏差消息
    ```shell
    int32 id
    float64 offset
    ```
    其中的id是标志的舵机ID号，offset是设置的偏移量

- PubOffset: 发送给上位机的当前舵机偏差的消息
    ```shell
    string[] name
    int32[] id
    float64[] offset
    ```
    name：代表当前的关节名字，其名称可以再`xr_hexapod.yaml`文件中找到
    id: 所有舵机的ID号
    offset: 所有舵机的偏移量
    注意：name与id与offset的关系是一一对应的

### servo_driver.cpp处理
:::tip
注意：因为以下代码使用了yaml-cpp，因此需要首先安装yaml-cpp，可以参照这个教程：https://blog.csdn.net/qq_42237381/article/details/118933993
:::
- 构造函数中定义offset文件
    ```cpp
    offset_adjust_sub_ = nh_.subscribe<hexapod_msgs::OffsetServo>("/xiaor/offset/subcriber", 5, &ServoDriver::offsetAdjustCallback, this);

    servo_offset_pub = nh_.advertise<hexapod_msgs::PubOffset>("/xiaor/offset/publisher", 10);
    // ROS_INFO("hexapod_description path: %s", ros::package::getPath("hexapod_description").c_str());
    offsetPath = ros::package::getPath("hexapod_description")+std::string("/params/xr_offset.yaml");
    if (!isFileExists_access(offsetPath))
    {
        ROS_INFO("generate offset file");
        generateServoOffset();
    }
    else
    {
        ROS_INFO("load offset params");
        loadServoOffset();
    }
    ```
- generateServoOffset
    ```cpp
    /**
    * 生成offset file文件，如果不存在的情况下
    */
    void ServoDriver::generateServoOffset()
    {
        YAML::Node node;
        node["copyright"].push_back("Do not edit this file, generate by XiaorGEEK,Copyright © 2023");
        for (size_t i = 0; i < SERVO_COUNT; i++)
        {
            node["id"].push_back(ID[i]);
            node["offset"].push_back(OFFSET[i]);
        }
        std::ofstream fout;
        fout.open(offsetPath);
        fout << node;
        fout.close();
    }
    ```
- loadServoOffset
    ```cpp
    /**
    * 加载offset file文件
    */
    void ServoDriver::loadServoOffset()
    {
        YAML::Node node = YAML::LoadFile(offsetPath);
        std::vector<int> ids = node["id"].as<std::vector<int>>();
        std::vector<float> offsets = node["offset"].as<std::vector<float>>();
        int length = ids.size();
        // ROS_INFO("ids length: %d", length);
        if (ids.size() != offsets.size())
        {
            ROS_WARN("servo offset file is broken, now generate from yaml file");
            generateServoOffset();
            return;
        }
        if (ids != ID)
        {
            ROS_WARN("servo offset file change, now generate new offset file");
            generateServoOffset();
            return;
        }
        for (size_t i = 0; i < ids.size(); i++)
        {
            ID[i] = ids[i];
            OFFSET[i] = offsets[i];
        }
    }

    bool ServoDriver::isFileExists_access(std::string &name)
    {
        return (access(name.c_str(), F_OK) != -1);
    }
    ```

## PC软件
> 要想使用PC舵机调节软件，小车首先需要安装rosbridge

- rosbridge安装
```shell
sudo apt-get install ros-<rosdistro>-rosbridge-server
```
- 启动rosbridge
```shell
roslaunch rosbridge_server rosbridge_websocket.launch
```
- launch文件启动
```xml
<launch>
  <include file="$(find rosbridge_server)/launch/rosbridge_websocket.launch" > 
  <!-- 默认端口为9090，为了与上位机对应，需要改成9090端口 -->
     <arg name="port" value="9090"/>
  </include>
</launch>
```

## git ssl错误
```shell
server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none
```
```shell
git config --global http.sslverify false

```
